\section{CIT-Storm}
\label{sect:citStorm}

As depicted in section \ref{sect:operators}, each operator has its own general standard behavior that is specialized by higher-order functions. This section gives a detailed description on how the operators are implemented in the cit-storm framework while leaving specialized behavior open to be defined by the end-user. 

\subsection{UDF-Bolt}
\label{sect:udfBolt}

All operators inherit from a general Bolt called \texttt{UDFBolt} that follows an extensible standard behavior:

\begin{enumerate}
	\item In a prepare phase all information that is provided by \storm\ about the cluster and topology configuration is gathered and stored. This is later referred to as the \textsl{prepare} event. After this phase the topology starts, and tuples begin to arrive at the bolt.
	\item The arrival of a tuple triggers the following sequence of operations:
		\begin{enumerate}
			\item The tuple is applied to an implementation of \texttt{IKeyConfig.getKeyOf(Tuple tuple)} to get the window key of it. 
		\end{enumerate}
\end{enumerate}

\subsection{Interfaces}
\label{sect:interfaces}
This section gives details about the most important structures than are used to extend a UDFBolts functionality.
\begin{description}
	\item[IOperator] \hfill \\
	The \ioperator\ interface provides one function: \\
	\texttt{execute(List<Tuple> input, \\ OutputCollector collector)} \\
	It is used to provided higher-order- or user-defined-functions. Depending on the bolt's windowing strategy the \texttt{input} list may always have a size of one like it is supposed to be in a \map\ or \filter\ operator. For these cases implementations of \ioperator\ exist like the \texttt{MapOperator} that in turn require an implementation of a \texttt{Mapper} interface that providers one method \texttt{Values map(Tuple tuple)}, what is more intuitive for a map operation.
	\item[IKeyConfig] \hfill \\
	The \ikeyconfig\ interface provides one function \\ \texttt{getKeyOf(Tuple tuple)}. It is used to assign keys to tuples in order to group them. Tuples that belong to the same group produce the same key. Commonly used keys are values of certain fields or a tuples source component or stream. For these types of commodity  \ikeyconfig\ implementations a factory \texttt{KeyConfigFactory} provides methods like \\
	 \texttt{byFields(String... fields)} or \texttt{bySource()} that return corresponding implementations.
	\item[Window] \hfill \\
	The most important methods the \iwindow\ interface provides are:\\
	\texttt{void add(I input)} to add a value \\
	\texttt{boolean isSatisfied()} to indicate its status \\
	\texttt{O flush()} to return its values and transition its state  \\
	All three methods are also combined in an atomic 
	\texttt{O addSafely(I input)}
	method, that first checks its state, if satisfied flushs it, then adds the value.
	A windows input and output types \texttt{I} and \texttt{O} are generic. \\
	\textsl{In a future release} there will be a \texttt{void tick()} method, that indicates that a second of time has passed. By that a \iwindow\ implementation may hold complete control about time constraints. Furthermore a \texttt{Context prepare()} method will be available to pass context information about cluster and topology configuration. 
\end{description}

\subsection{Windows}
\label{sect:windows}

\subsubsection{CountWindows}

\subsubsection{TimeWindows}